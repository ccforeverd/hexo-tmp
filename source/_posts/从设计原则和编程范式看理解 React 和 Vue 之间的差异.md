# 从设计原则和编程范式看理解 React 和 Vue 之间的差异

> 未经审视的代码是不值得写的
>
> ​                                                          ——沃兹吉 · 硕德

本文专注于设计原则和编程范式，不专注于代码。

## 目标

探讨 React 和 Vue 之间的根本差异，帮助大家思考在不同框架的基础上如何更好的组织代码。

## 前言

React 和 Vue 之间的对<del>决</del>比是前端圈最细问乐见的主题。相关内容通常会从构建工具、代码形态、状态管理、生态系统等偏实践的方式去<del>搞事</del>比较它们。对于**初尝这两个框架**和处于**选型困难**的开发者来说，这能有一个快速预览的效果。

然而，随着实践的深入，由于对框架本身缺乏认识导致的一些问题会渐渐的出现，本文则是从框架本身出发来阐述一些 React 和 Vue 在本质上的区别，看看脱离代码，我们能知道些什么。

## 框架的形态

由于 EcmaScript 及相关生态的不断发展，现在前端框架的形态早已不再限于一些简单的 `.js` 文件的相加，渐渐的发展成了由以下几个部分组成：

- 特殊语法
  - 概念：由领域特定语言(DSL，Domain Specific Language) + API
  - 例：Angular、Vue、Svelte 等框架的模板语法、JSX
- 附加语义
  - 概念：组件及其核心逻辑在框架中的形态，简单来说就是我们在基于某个框架聊组件、状态等概念的时候，是在聊什么
  - 例：Vue 和 Angular 的组件是对象，而 React 是函数，Svelte 是...它比较另类
- 运行时
  - 概念：即框架核心，用于驱动整个框架的功能特性
  - 例：每种框架都会有相应的 runtime
- 心智模型
  - 概念：框架的设计理念、编程范式等一系列因素构成的心智模型，是一个纯概念性的方面
  - 例：Angular 和 Vue 都是在 OOP 基础上进行了一些 FP 的集成，而 React 则逐步走向了更加纯粹 的 FP 范式

本文的阐述方式将以“提问+解答”的方式进行，提问则会根据以上内容进行铺开，基本以 2W1H 的思路前进

#### 2W1H

即 What -> WHy -> How，根据框架的形态，我们梳理以下几个基本问题：

- What
  - 它是什么？
  - 它的组件是什么？（组件的语义）
  - 它靠什么控制组件？（核心附加语义）
- Why
  - 它为什么是一个...？
  - 它的组件为什么是...？（编程范式）
  - 它为什么要这样控制组件？（心智模型）
- How
  - 怎样看待它？（如何更好的利用它）
  - 写出的组件应该是什么样的？（与其开发理念对齐）
  - 组件之间如何交互？（要遵循什么样的原则）

## 三大框架

在开始之前，我们有必要对最负盛名的“三大框架”做一个梳理，提供一个背景知识板

近两年来，Svelte 在国外有着不错的势头，几乎要盖过 Angular 来成为三大框架之一，但其在国内的名气依然无法与 Angular 相提并论，因此我们这里讨论的范畴依然是 AVR。

下面我们从三个角度梳理它们，分别是**“框架or库”、“特性扩展”、“Who is Running it”**。

#### Angular

- **框架or库**：从概念上来看，三大框架中唯有 Angular 是**真正意义上的框架**，它由如 SpringBoot 一样支持了其专注领域的几乎所有特性（Feature-Rich），高度的标准化和规范化让基于 Angular 开发的应用具有很强的稳定性

  然而，对于大部分的前端开发者来说，Angular 的复杂性也远远高于其他两个框架——不仅仅是 TypeScript 语言本身的学习成本，还需要理解依赖注入（DI）、MVC 等设计模式。由此带来的门槛提升使其通常被用于开发需要极高稳定性和可维护性的大型项目

- **特性扩展**：只要是 Angular 觉得有必要的，都内建或在内建的途中，你可以在这座“大教堂”里做任何事情

- **Who is Running it**：得益于 Google 强大的技术实力和丰富的开发资源，Angular 的野心或许不仅仅是一个被人用于比来比去然后不用的牛刀，而是要成为一个终极的前端项目开发解决方案，为 TypeScript-Ready 的团队提供最完美的选择。

#### React

- **框架or库**：React 在这个问题上比较奇怪，它从来就不是一个框架，而是一个专注于构建用户界面的库，但其极高的使用比例和庞大的生态系统使得大家都下意识的将它视作框架。就像 React 的名字一样，其实它一点都不 React，但表现得很 React，所以大家都觉得它 React
- **特性扩展**：React 拥有无与伦比的生态系统，你可以在“集市”上找到各种各样的库来实现你想要的特性，甚至某些团队基于这些库开发了衍生的完整框架——如 UmiJS
- **Who is Running it**：React 的诞生之初就是为 Facebook 服务的，而在其发展过程中也不断的体现着 Facebook 优先的价值观，甚至为了项目规范，与社区闹过一些不愉快。所以我们需要明确一个概念，尽管 React 现在的社区化程度很高，但其核心依然由 Facebook 控制，结晶的主要是 Facebook 工程师们的想法，所以它依然像是大厂推出的一个产品，我们需要认真的阅读说明书

#### Vue

- **框架or库**：Vue 的模式介于 Angular 和 React 之间，是一个渐进式的框架（Progressive Framework），它一直在各种技术间进行取舍，不断改进。官方提供了一些比较核心的特性，但这些特性之间并未有什么很强的关联，**你完全可以独立的使用 Vue core 进行页面的开发**，如果你希望使用某个额外的特性，你可能会找到官方的方案，也能在社区里找到更多的选择

  **PS**：有许多 Anti-Vue 人士常常将 Vue 抄袭 Angular 和 React 挂在嘴边，其实这是不对的，在开发世界，用自己的方式去实现某个特性，或者说是更好的实现某个特性，是作为抄袭来讲的话，也许这个领域会无聊得难以附加。当然了，有些开发者也只是调侃一下，最好不要怀着恶意便是

- **特性扩展**：前面已经提到，除 Vue 的核心外，所有的特性都是 Optional 的，但其生态系统眼下与 React 还有很大差异，所以你可能还是会用到很多官方方案
- **Who is Running it**：Contributors！当然了，众所周知 Vue 的作者是尤雨溪，但随着时间的退役，Vue 早已不止是纯粹的个人项目，而是有成千上万的开发者参与到其中。这样的好处是，它的进化一定是和社区意愿息息相关的，所以不用担心它里面的一些概念会过时。然而，也由于没有大厂加持，其生态系统的发展或许会比较慢一些

好了！以上就是简单的一个前端框架现状的简单梳理，下面开始来向 React 和 Vue 提问吧！

## 下饭！

下饭开始

### React

#### What

- **它是什么？**
  - 答案：[A JavaScript library for building user interfaces](https://reactjs.org/)，翻译为：“一个超级牛的库”（误）
- **它的组件是什么？**
  - 答案：React 为组件定制的语义是**函数**
- **它靠什么控制组件？**
  - 答案：上下文（context）
  - 解析：函数

#### Why

- **它为什么是一个库？**

  - 答案：

    > 一般而言我们[拒绝添加](https://www.youtube.com/watch?v=4anAwXYqLG8)一些开发者可以实现的特性。我们不想因为无用的库代码使得大家的应用变的累赘，然而也有特例。
    >
    > 比如，如果 React 不支持内部 state 或者生命周期函数，大家会为此创建自己的抽象。当有多种抽象竞争的时候，React 不能强制使用或利用这些抽象中的任何一个。React 必须选择最基本的共同点。
    >
    > 这就是我们增加 React 特性的原因。如果我们发现很多组件以不兼容或者不高效的方式实现了某些特性，我们会倾向在 React 中实现它。我们轻易不这样做，只有我们非常确定提高抽象层级有助于整个生态系统时我们才会这样做。State、生命周期函数、跨浏览器事件的正规化都是很好的范例。
    >
    > 我们总是和社区一起商议这样的优化提议。你可以在 React 问题跟踪的 [“big picture”](https://github.com/facebook/react/issues?q=is:open+is:issue+label:"Type:+Big+Picture") 标签上找到一些这样的讨论。
    >
    > ——[共用抽象](https://zh-hans.reactjs.org/docs/design-principles.html#common-abstraction)

    可以看出，React 团队为了保持其代码库的纯洁性，还是做了相当大的努力。当然了，Facebook 优先也是一个重要的因素，如果某个特性不在 Facebook 内部的呼声高了起来，那么它排上日程的可能性会大一些

- **它的组件为什么是一个函数？**

  - 答案：

    > 组件之间的组合是 React 的重要特征。不同开发者写的组件应该可以一起正常执行。给一个组件添加功能，而不会对整个代码库造成涟漪似的变化，这对我们很重要。
    >
    > 比如，应该可以在不影响任何使用它的组件的情况下，将一些内部 state 引入该组件。类似的，在必要的情况下可以在任何组件里添加一些初始化和销毁的代码。
    >
    > 在组件中使用 state 或者生命周期函数没什么“不好”。跟所有强大的特性一样，应该适度使用它们，我们并不打算移除他们。相反，我们认为他们是 React 之所以好用的一部分。我们未来也许会启用[更多函数模式](https://github.com/reactjs/react-future/tree/master/07 - Returning State)，但内部 state 和生命周期函数都会在里面。
    >
    > 人们常常认为组件“只是函数”，但在我们看来，组件要好用的话，需要的不止这些。在 React 中，组件描述了任何可组合的行为，包含渲染、生命周期和 state。一些类似 [Relay](https://facebook.github.io/relay/) 的外部库给组件带来了其他增强功能，比如描述数据之间的依赖关系。有可能这些做法会以某种形式回到 React 中。
    >
    > ——[组合](https://zh-hans.reactjs.org/docs/design-principles.html#composition)

    里面提到了“函数模式”，其实这就是弥漫在整个 React 设计中浓浓的**函数式编程**理念。函数式编程提倡通过组合（composition）、管道（pipe）等方式对纯函数进行连接，来实现一系列功能。而纯函数具有的特点则是“相同的输入总是得到相同的输出”，因此纯函数是可预测（predictable）的。那么相对应的，什么函数不是纯函数呢——具有副作用（effect）的函数则不能称作纯函数，因为副作用将导致函数的结果不可预测，那么这个函数是不稳定、不安全的，我们简单举个🌰进行说明：

    ```javascript
    let familyCount = 7; // 孩子、父母、姥姥姥爷，爷爷奶奶
    
    // 获取全家人的数量
    function getAllFamily() {
      return familyCount;
    }
    
    // 离婚
    function divorce() {
      familyCount -= 1;
    }
    ```

    我们假设姥姥姥爷和爷爷奶奶会经常调用 `getAllFamily` 来体会完整家庭的快乐，然而某一天父母调用了 `divorce` 函数，没有告知长辈，这个时候，他们再调用 `getAllFamily`，就会出现“这么大的事你竟然不告诉我？！”这种经典剧情

    回到代码上来，`divorce`  函数一经运行，修改了一个全局的变量，这是发生在函数之外的影响，即副作用。而它导致了 `getAllFamily` 函数的结果产生变化，如果调用者并不知道 `divorce` 函数的调用，那么调用者将不知道如何处理，或是得不到期许的输出，这可能引起严重的问题。

    其实这便是 OOP 编程范式为人诟病的一点，因为在 OOP 编程范式中，数据是可变的，它使得对象有了多态等能力。但是，在并发场景下，一个可变数据有可能导致一连串相关的方法产生问题，这时候就出现了锁的概念，使得整个系统越来越复杂。

    而函数式编程则遵循**数据不可变**的原则，它的每一次工作都是由一连串的纯函数共同完成，在这个过程中，不会对本次工作之外的环境产生任何影响，因此其输出是安全可靠的。

    回到主题上来，React 则是希望将这种安全可靠的范式带到组件开发中，使得每个组件的行为都可预测，并且稳定可靠，这不仅能保证用户界面得到正确的展示，也使得测试变得更加的有效。

    我们来分解一个简单的组件来看看 React 是如何践行这一切的：

    ```React
    const Comp = props => <h1>{ props.title }</h1>
    ```

    这是一个最简单的组件，我们梳理一下其中的元素：

    - Comp：组件名称，本质上是一个函数签名
    - props：组件的属性，本质上就是这个函数参数
    - H1：函数的返回值，它使用了 props 中的一个属性，本质上则是把函数参数通过某种形式呈现给用户

    这是一个活生生的纯函数！

    同时，在 React 中，直接对 props 进行修改，会导致代码出错甚至崩掉，因为它是**不可变**的！而每一次 props 的传入，你都能知道它将在用户界面上以什么样的形式呈现

    所以，我们在设计和控制组件的时候，需要关注的便是，**如何在 props -> 组件展示这个过程中寻找到最佳的路径！**

    另一方面，引文中也提到了，React 为了满足 UI 组件本身的需要，引入了“生命周期”、“state”等概念，而 state 应当在“不影响任何使用它的组件的情况下”进行使用，并且要在生命周期中明确的对它产生的影响进行销毁或重置。也就是说，“state”和“生命周期”这两样东西其实并非 React 的核心理念，其核心理念其实是建立在函数式编程的**数据不可变**基础上的 props -> 组件这个过程中的控制

  * 延伸：引文中提到了 React 将在以后启用更多的函数模式，这背后其实具有一个 React 实现方式的背景——**Fiber 和 Concurrency**

- 它为什么使用上下文？
  - 先口述





